new
ensures
no
conforms
:-
NO_OUTPUT.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks. 
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks.
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
NO_OUTPUT.
No output.
NO_OUTPUT.
The extracted relevant part of the context is:

Note that TRUE and FALSE are automatically deﬁned on the user’s behalf, though they are
not keywords.

By convention, the names of user-deﬁned constants should consist of all uppercase
characters and be at least two characters long. This convention helps to distinguish con-
stants from other identiﬁers. Two user-deﬁned constants denote the same value are if and
only if they have the same. For example:
TRUE = TRUE, FALSE = FALSE, TRUE != FALSE, RED != BLUE
> Context:
>>
1.2. DATA CONSTRUCTORS
5
Multi-Line String Escapes#
Syntax
Result#
' ' " "
Produces the sequence ' " .
" " ' '
Produces the sequence " ' .
Table 1.2: Table of multi-line string escapes.
1.2
DATA CONSTRUCTORS
Complex data values are created by functions called data constructors (or constructors for
short). An n-ary data constructor f takes n data values as arguments and returns a new
data value. Here are some examples:
Person("John", "Smith"), Node(1, Node(2, NIL, NIL), Node(3, NIL, NIL))
The Person(,) constructor creates Person values from two string arguments. The Node(,,)
constructor builds binary trees of integer keys. The arguments to Node are: (1) an integer
key, (2) a left-subtree (or the constant NIL if none) and (3) a right-subtree (or the constant
NIL if none).
Data constructors are proper functions, i.e. they always produce the same values from
the same inputs.
> Context:
1: class Node {{
2:
...
3:
Node (int Key, Node left, Node right)
4:
{{ ... }}
5: }}
6:
7: Node x = new Node(1, null, null);
8: Node y = new Node(1, null, null);
9: if (x != y) {{
10:
print("Different");
11: }}
NO_OUTPUT.
> Context:
>>>
A data type (or just a type) is a expression standing for a set of values. Table 1.3 lists the
built-in data types and their meanings. In addition, other types can be deﬁned. Suppose
f (...) is an n-ary constructor, then the type f stands for the range of the constructor f .
The extracted relevant part of the context is:

Built-in Data Types#
Name
Meaning#
Real
The set of all numeric values.
Integer
The set of all integers.
Natural
The set of all non-negative integers.
PosInteger
The set of all positive integers.
NegInteger
The set of all negative integers.
String
The set of all string integers.
Boolean
The set of constants TRUE and FALSE.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks.
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint*

Grammar keywords:
- new
- ensures
- no
- conforms
- :- 

Nesting rules and what’s required inside each block:

- The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks.

Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

Nesting rules and what’s required inside each block.
> domain D {{ Id ::= Integer. }} 
> domain D' {{ Id ::= String. }}
> Error: Conﬂicting deﬁnitions of type Id
1: domain D
2: {{
3:
Id ::= Integer.
4:
Id ::= String.
5: }}
The extracted relevant part of the context is:

MULA accepts any set of type declarations as long as their meaning is consistent across the
module. For example, this module is legal because it deﬁnes Id in two equivalent ways.
Legal: All deﬁnitions of type Id are equivalent
1: domain D
2: {{
3:
Id ::= Integer.
4:
Id ::= NegInteger + {{0}} + PosInteger.
5: }}
*domain*
- domain Colors
- NamedColor ::= {{ RED, GREEN, BLUE }}
- Color
::= {{ RED, GREEN, BLUE, 0..16777215 }}
*domain*
{{
    *transform*
    {{
        *machine*
        {{
            *rule*
            {{
                *type*
                {{
                    *constraint*
                }}
            }}
        }}
    }}
}}

*grammar keywords*
- `new`
- `ensures`
- `no`
- `conforms`
- `:-`

*nesting rules*
- The structure of `domain` block is defined by the following grammar:
  - `domain Colors` is a valid domain declaration.
- Each `transform`, `machine`, and `rule` block can be nested inside another block, but there are no nesting requirements specified.
> Context:
>>>
Data constructors are similar to structs or records in C-like languages, but more general.
Consider the task of deﬁning a node struct in C#. The following code is illegal because the
struct Node directly depends on Node values.
Cannot deﬁne a struct that depends directly on itself.
1: struct Node
2: {{
3:
int key; Node left; Node right;
4:
Node(int k, Node l, Node r)
5:
{{ key = k; left = l; right = r; }}
6: }};
The problem is that Node must have a default value, and there is no way to construct
this default value. The deﬁnition becomes legal if str uct is replaced with class and then
null is a valid default value for the lef t and r ight ﬁelds. However, this comes with the
price that node equality is signiﬁcantly weakened, i.e. n == m only if the variables n and m
hold the same reference. In other words, binary trees cannot be compared as if they were
just values.
The declarations of FORMULA constructors can cyclically depend on themselves.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> 
> 1: domain Trees
> 2: {{
> 3:
> Node ::= (key
> : Integer,
> 4:
> left : Node + {{NIL}},
> 5:
> right: Node + {{NIL}}).
> 6: }}
> 
> The only requirement on constructors is that there must be some arguments of ﬁnite
> size satisfying the type constraints of the constructor. For example, a minimal node value
> can be constructed by:
> Node(0, NIL, NIL)
> 
1: domain Trees
2: {{
3:
Node ::= (key
: Integer,
4:
left : Node,
5:
right: Node + {{ NIL}}).
6: }}
The problem is the lef t ﬁeld can only take a node value, but the only way to construct
a node value is to apply the node constructor. Therefore, only an inﬁnitely long sequence
of node applications could construct such a value.
> 
1: domain Trees
2: {{
3:
Node ::= (key
: Integer,
4:
left : Node + {{ NIL}},
5:
right: Node + {{ NIL}}).
6:
7:
Node ::= (key: Integer, left: Tree, right: Tree).
8:
Tree ::= Node + {{ NIL}}.
9: }}
> Node ::= (key: Integer, left: Tree, right: Tree).
> Tree ::= Node | NIL.
> The type Tree is a super-type of the type Node, because in contains all node values and 
> the additional value NIL.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> Context:
>>
(2.1)
Classically, a directed graph is represented by a set of vertices V and set of edges E; each
e ∈E is a pair of vertices. Furthermore, suppose vertices are represented by integers, then
the set of all ﬁnite integer-labeled graphs is:
G
de f
= {{(V,E) | V ⊂Z∧E ⊆V ×V }}
where every V is ﬁnite.
Here is an example of a speciﬁc graph:
Gex
de f
= ({{1,2,100}},{{(1,2),(100,100)}}).
FORMULA does not directly support sets and relations, so we cannot express vertices
and edges as sets. Instead, integer-labeled graphs are represented using two data construc-
tors V and E as follows:
13
The extracted relevant part of the context is:

> CHAPTER 2. DOMAINS AND MODELS
> 
> Example 2.1 (Integer-labeled graphs).
> 1: domain IntGraphs
> 2: {{
> 3:
> V ::= new (lbl: Integer).
> 4:
> E ::= new (src: V, dst: V).
> 5: }}
> 
> Example 2.2 (A small graph).
> 1: model Gex of IntGraphs
> 2: {{
> 3:
> V(1).
> 4:
> V(2).
> 5:
> V(100).
> 6:
> E(V(1), V(2)).
> 7:
> E(V(100), V(100)).
> 8: }}
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint*

Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

query can be rewritten as:
[]> query Gex E(_, y), E(y, _)
Underscores are useful for visually emphasizing those variables that appear in multiple
places. Queries can also be formed from built-in relations and constraints.
[]> query Gex V(x), x > 20
Constructor labels can be used to write more readable queries. The query:
“Is there an edge whose source vertex has a label greater than 100?”
can be written as:
[]> query Gex e is E, e.src.lbl > 100
The constraint e is E requires e to be a provable value of type E.
The order in which conjuncts are written does not matter; the semantics of a query is the
same. However, queries can only check for properties that can be answered using model
assertions and a ﬁnite number of evaluations. For example, this query is not allowed:
[]> query Gex x > 100
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks.
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

> Context:
>>>
Did we capture this constraint correctly? The answer is that it depends on how we choose
to deﬁne the set of vertices V present in a model M. There are two options: (1) Every
occurrence of a vertex value anywhere in the model is implicitly a member of V . (2) Only
those vertices that are provable are members of V . Consider this example:
1: model SomeVertices of IntGraphs
2: {{
3:
V(1).
4:
E(V(1), V(2)).
5: }}
Under the ﬁrst deﬁnition, the vertex set for this model is {{1,2}} and the edge set is {{(1,2)}}.
This satisﬁes the constraint E ⊆V ×V . Under the second deﬁnition the vertex set is only
{{1}} and the edge set violates the constraint because 2 ∉V . By default, FORMULA uses the
second and more restrictive deﬁnition: E ⊆V ×V means every argument to E(,) must be
provable. Models violating this property do not conform to the domain. These kinds of
constraints are so common that FORMULA automatically introduces them. To see this,
add the code for SomeVer tices to ex1.4ml and run this query:
> Question: 
            Extract a **technical cheat sheet** of the FORMULA programming language.
            Focus only on:
                - The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
                - Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
                - Nesting rules and what’s required inside each block.
            DO NOT include historical background, tooling usage, or example explanations.

> Context:
>>>
binary tree constructor:
Node ::= new (left: any Node + {{NIL}}, right: any Node + {{NIL}}).
Of course, binary trees can also be encoded using ﬁnite relations, but the encoding is a
different one from the recursive constructor shown above.
2.4
FINITE FUNCTIONS.
Finite functions are a special case of ﬁnite relations satisfying additional constraints. Con-
sider the representation of a forest F of binary trees as follows:
F
de f
= (V,parent)
where parent : V →{{⊤}}∪({{L,R}}×V ).
The set V contains the vertices of the forest and the function parent assigns to each vertex v
its parent: parent(v) = (L,u) if v is the left child of u; parent(v) = (R,u) if v is the right child
> 
CHAPTER 2. DOMAINS AND MODELS
of u; parent(v) = ⊤if v is a root. Additionally, the parent function should not introduce a
cycle, but we ignore this constraint for now. The parent function can be treated as a ﬁnite
relation by listing its input-output pairs. Consider this forest where 1 is a root, 2 is its left
child, and 3 is its right child:
Fex
de f
= ({{1,2,3}},{{(1,⊤),(2,(L,1)),(3,(R,1))}}).
The parent relation encodes a total ﬁnite function if it is total on the domain:
∀v ∈V. ∃x. (v,x) ∈parent,
and every input is related to a unique output:
∀v ∈V. ∀x, y. (v,x) ∈parent ∧(v, y) ∈parent ⇒x = y.

> 
domain RelTrees
2: {{
3:
V
::= new (lbl: Integer).
4:
Parent
::= fun (chld: V => cxt: any {{ROOT}} + Context).
new (lbl: Integer).
Parent
::= fun (chld: V => cxt: any {{ROOT}} + Context).
Context ::= new (childPos: {{LFT, RT}}, prnt: V).
 
Grammar keywords:
- new
- ensures
- no
- conforms
- :-
 
Nesting rules:
- domain of the relation and the arguments on the right side correspond to the codomain.
- uniqueness constraints are injected by the f un modiﬁer.
- totality constraints are injected by the totality arrow =>.
NO_OUTPUT.
> domain AlgTrees
> {{
> Node ::= new (left: any Node + {{NIL}},
> right: any Node + {{NIL}}).
> Root ::= new (root: any Node).
> }}
> model Fex' of AlgTrees
> {{
> Root(
> Node(
> Node(NIL, NIL),
> Node(NIL, NIL))).
> }}
> structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

1: model InfiniteTree of AlgTrees
2: {{
3:
infinite_left
is Node(infinite_right, NIL).
4:
infinite_right is Node(NIL, infinite_right).
5:
Root(Node(infinite_left, infinite_right)).
6: }}

This appears to be an example of a FORMULA programming language definition, specifically a model block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks. 
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
*domain*, *model*, *transform*, *machine*, *rule*, *type*, *constraint* blocks.
Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

model M of D at "foo.4ml" {{ ... }}

model M1 of D at "..\\..\\version1.4ml" {{ ... }}
model M2 of D at '"..\..\version2.4ml"' {{ ... }}
> model M of D at "version2.4ml" {{ ... }}
> modules.D = "D at foo.4ml"
> modules.D' = "D' at foo.4ml"
> model M of D {{ ... }}
No output.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

*   `anc ::= (ancestor: V, descendant: V).`
> Extract a **technical cheat sheet** of the FORMULA programming language.
> 
> - The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> - Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> - Nesting rules and what’s required inside each block.
> 
> DO NOT include historical background, tooling usage, or example explanations.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

3:
RelTrees.hasCycle :- anc(u, w), anc(w, u).
The extracted relevant part of the context is:

3.2. RULE BODIES
29
Matching Constraints#
Syntax
Meaning#
q
true if the derived constant q is provable; false otherwise.
f(t1,...,tn)
true for every assignment of variables where f (t1,...,tn) is
provable; false otherwise.
x is f(t1,...,tn)
true for every assigment of variables where f (t1,...,tn) is
provable and x = f (t1,...,tn); false otherwise.
x is T
true if x is a provable value and a member of the type
named T; false otherwise.

Table 3.1: Table of matching constraints.
Interpreted Predicates#
Syntax
Meaning#
no {{...}}
true if the set comprehension is empty; false otherwise.
t = t’
true if t and t′ are the same value; false otherwise.
t != t’
true if t and t′ are diﬀerent values; false otherwise.
t < t’
true if t is less than t′ in the order of values; false otherwise.
t <= t’
true if t is less than equal to t′ in the order of values; false otherwise.
t > t’
true if t is greater than t′ in the order of values; false otherwise.
t >= t’

This part of the context appears to be relevant to the question about the FORMULA programming language, specifically regarding grammar keywords and their valid use.
> Context:
>>
t > t’
true if t is greater than t′ in the order of values; false otherwise.
t >= t’
true if t is greater than or equal to t′ in the order of values; false
otherwise.
x : T
true if x is a member of the type named T; false otherwise.
Table 3.2: Table of interpreted predicates.
3.2
RULE BODIES
The body of a rule is a conjunction of constraints. Constraints can be either matching con-
tstraints or interpreted predicates. A matching constraint is satisﬁed if there is some substi-
tution of the variables where the resulting value is provable. An interpreted predicate is
satisﬁed if there is some substitution of the variables where a special predicate evaluates to
true. Tables 3.1 and 3.2 list the forms of matching constraints and interpreted predicates.
The order in which conjuncts appear is irrelevant; as with queries, all variables must be
orientable.
NO_OUTPUT.
*AS IS*

> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
> 
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> 
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> 
> Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> 
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> 
> Nesting rules and what’s required inside each block.
> Context:
>>>
i.e. the number of distinct edges coming into a vertex. One might be tempted to write rules
such as:
1: indeg_atleast_2(v) :-
2:
v is V,
3:
e1 is E(_, v), e2 is E(_, v),
4:
e1 != e2.
5:
6: indeg_atleast_3(v) :-
7:
v is V,
8:
e1 is E(_, v), e2 is E(_, v), e3 is E(_, v),
9:
e1 != e2, e1 != e3, e2 != e3.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

A general rule has for the form:
head1, ..., headm :- body1; ...; bodyn.
It is equivalent to the set of rules:
head1, ..., headm :- body1.
...
head1, ..., headm :- bodyn.
A general rules proves all heads head1,...,headm for every satisfying assignment of the
body. Each head must be formed from constants, constructors, and variables. A rule head
must satisfy the following properties:
• Under all circumstances, a rule head must evaluate to a derived constant or a con-
structed value.
• Under all circumstances, a rule head must evaluate to a well-typed value.
• Every variable appearing in a rule head must appear at the top level of the body.
(The variable cannot be introduced by a comprehension.)
All of these properties are checked at compile time and generate errors if violated.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
The extracted relevant part of the context is:

1:
smallInDegree :- no {{ v | indeg(v, k), k > 3 }}.
2:
indeg(v, k)
:- v is V, k = count({{ e | e is E(_, v)}}).
A graph has a “small in-degree” if no in-degree is greater than three.
The extracted relevant part of the context is:

>
D.conforms
Provable if all conformance constraints are satisﬁed.
D.notRelational
Provable if a provable value contains f (...,ti,...), f is rela-
tional on position i, ti = g(...), and g(...) is not provable.
D.notFunctional
Provable if a constructor is declared to be a (partial) func-
tion, but its provable values map an element from the
domain of the function to several distinct elements in the
codomain.
D.notTotal
Provable if a constructor is declared to be a total func-
tion, but some element of its domain is not mapped to an
element of its codomain.
D.notInjective
Provable if a constructor is declared to be a (partial) in-
jection, but several elements of its domain are mapped to
the same element in its codomain.
D.notInvTotal
Provable if a constructor is declared to be a (partial) sur-
jection, but there is an element of its codomain for which
no element of the domain is mapped.
NO_OUTPUT.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
*domain*: 
- domain DAGs
- domain RelTrees_Final
- {{
New-kind constructors.
- V ::= new (lbl: Integer).
- E ::= new (src: V, dst: V).
- path ::= (V, V).
- anc ::= (ancestor: V, descendant: V).

*transform*: 

*machine*: 

*rule*: 
- conforms no path(u,u)

*type*: 

*constraint*: 
- conforms
* Extracted relevant parts of the context:

- `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks structure.
- Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
- Nesting rules and what’s required inside each block.

Note: The specific details of the extracted parts are based on the provided context.
NO_OUTPUT.
NO_OUTPUT.
NO_OUTPUT.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules:
  - A variable introduced in a rule is placed in the root namespace.
  - The new-kind user constant Cnst is placed in the root.
  - The derived-kind user constant DerCnst is placed in the namespace D.
> Extract a **technical cheat sheet** of the FORMULA programming language.
> 
> Focus only on:
>     - The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
>     - Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
>     - Nesting rules and what’s required inside each block.
> 
> DO NOT include historical background, tooling usage, or example explanations.

>>>
tors. Placed in the namespace D along with D.#Data.
D.Any
A predeﬁned symbol deﬁned to be the union of all types in the
domain. Placed in the namespace D along with D.#Any.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> 
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> 
> Nesting rules and what’s required inside each block.
> DOMAIN COMPOSITION
Domains are composed by writing:
domain D includes D1, ..., Dn {{ ... }}
Composition imports all the declarations of D1,...,Dn into D. If a symbol is in namespace
n in Di, then it remains in namespace n in D. If this merging causes a symbol to receive
contradictory declarations, then an error is reported. As a corollary, importing the same
domain several times has no effect, because all declarations trivially agree.

This part of the context appears relevant to answer the question about the structure of `domain` blocks in the FORMULA programming language.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
> Extract a **technical cheat sheet** of the FORMULA programming language.
> 
> Focus only on:
>     - The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
>     - Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
>     - Nesting rules and what’s required inside each block.
>
>>>
48
CHAPTER 4. DOMAIN AND MODEL COMPOSITION
The extracted relevant part of the context is:

1: model LittleIso of IsoDAGs
2: {{
3:
v1L is Left.V(1).
4:
v2L is Left.V(2).
5:
v1R is Right.V(1).
6:
v2R is Right.V(2).
7:
8:
Left.E(v1L, v2L).
9:
Right.E(v2R, v1R).
10:
11:
Iso(v1L, v2R).
12:
Iso(v2L, v1R).
13: }}
NO_OUTPUT.
> 
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
NO_OUTPUT.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.

> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.

> Nesting rules and what’s required inside each block.
NO_OUTPUT.
> The structure of `domain`, `model`, `transform`, `machine`, `rule`, `type`, `constraint` blocks.
> Grammar keywords (like `new`, `ensures`, `no`, `conforms`, `:-`) and their valid use.
> Nesting rules and what’s required inside each block.
NO_OUTPUT.